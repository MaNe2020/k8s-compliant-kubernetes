global:
  ck8sVersion: any
  cloudProvider: baremetal
  clusterName: glasswall-ovh-kubespray-sc
  baseDomain: glasswall-ck8s-proxy.com
  opsDomain: ops.glasswall-ck8s-proxy.com
  issuer: letsencrypt-prod
  verifyTls: false
  storageClass: vsphere-csi
  clusterDns: 10.43.0.10
objectStorage:
  # Options are "s3", "gcs", or "none"
  # If "none", remember to disable features that depend on object storage:
  #   all backups (velero, harbor, influxdb, elasticsearch), sc logs (fluentd)
  #   Also set harbor persistence to "filesystem" or "swift"
  # Otherwise configure the features to match this type.
  type: s3
  s3:
    region: us-east-1
    regionAddress: s3.us-east-1.amazonaws.com
    regionEndpoint: https://s3.us-east-1.amazonaws.com
  buckets:
    harbor: glasswall-ovh-kubespray-harbor
    velero: glasswall-ovh-kubespray-velero
    elasticsearch: glasswall-ovh-kubespray-es-backup
    influxDB: glasswall-ovh-kubespray-influxdb
    scFluentd: glasswall-ovh-kubespray-sc-logs
user:
  grafana:
    enabled: true
    resources:
      limits:
        cpu: 100m
        memory: 128Mi
      requests:
        cpu: 100m
        memory: 128Mi
    tolerations: []
    affinity: {}
    nodeSelector: {}
    userGroups:
      grafanaAdmin: grafana_admin #maps to grafana role admin
      grafanaEditor: grafana_editor #maps to grafana role editor
      grafanaViewer: grafana_viewer #maps to grafana role viewer
  # Todo remove dependencie on alertmanager from service cluster
  alertmanager:
    enabled: false
    namespace: monitoring
    ingress:
      enabled: false
harbor:
  enabled: true
  tolerations: []
  affinity: {}
  nodeSelector: {}
  chartmuseum:
    persistentVolumeClaim:
      size: 5Gi
  core:
    resources:
      requests:
        memory: 256Mi
        cpu: 100m
      limits:
        memory: 512Mi
        cpu: 200m
  database:
    persistentVolumeClaim:
      size: 1Gi
  jobservice:
    persistentVolumeClaim:
      size: 1Gi
    resources:
      requests:
        memory: 256Mi
        cpu: 100m
      limits:
        memory: 512Mi
        cpu: 200m
  registry:
    persistentVolumeClaim:
      size: 5Gi
    resources:
      requests:
        memory: 256Mi
        cpu: 100m
      limits:
        memory: 512Mi
        cpu: 200m
  redis:
    persistentVolumeClaim:
      size: 1Gi
  notary:
    resources:
      requests:
        memory: 256Mi
        cpu: 100m
      limits:
        memory: 512Mi
        cpu: 200m
  persistence:
    # Valid options are "filesystem" (persistent volume), "swift", or "objectStorage" (matching global config)
    type: objectStorage
    disableRedirect: false
  oidc:
    #group claim name used by OIDC Provider
    groupClaimName: set-me
    scope: openid,email,profile,offline_access,groups
  backup:
    enabled: true
prometheus:
  storage:
    size: 2Gi
  retention:
    size: 1GiB
    age: 3d
    alertmanager: 72h
  resources:
    requests:
      memory: 1Gi
      cpu: 300m
    limits:
      memory: 2Gi
      cpu: "1"
  tolerations: []
  affinity: {}
  nodeSelector: {}
  wcReader:
    resources:
      requests:
        memory: 1Gi
        cpu: 300m
      limits:
        memory: 2Gi
        cpu: "1"
    storage:
      size: 2Gi
    retention:
      size: 1GiB
      age: 3d
    tolerations: []
    affinity: {}
    nodeSelector: {}
dex:
  # supported: google|okta|aaa
  oidcProvider: google
  allowedDomains:
    - example.com
  enableStaticLogin: true
  resources:
    limits:
      cpu: 100m
      memory: 50Mi
    requests:
      cpu: 100m
      memory: 50Mi
  tolerations: []
  affinity: {}
  nodeSelector: {}
  # These two settings are curently only used by okta. If you don't need the groups claims, both options can be set to 'false'.
  # 'insecureSkipEmailVerified' should only be set to 'true' if the user's okta
  # configuration does not require a user to verify their identity to okta when their okta account is being created. This is not recommended.
  insecureSkipEmailVerified: false
  insecureEnableGroups: true
kibana:
  # Note sso is enabled via `elasticsearch.sso.enabled`
  resources: {}
  nodeSelector: {}
  tolerations: []
  affinity: {}
elasticsearch:
  snapshotRepository: elastic-snapshots
  # Create initial indices upon first startup
  createIndices: true
  # Single-sign-on using OIDC
  sso:
    enabled: false
    # Where to find subject
    subject_key: email
    # Where to find roles
    roles_key: groups
    # Scope
    scope: openid profile email
  masterNode:
    count: 1
    storageSize: 1Gi
    javaOpts: -Xms512m -Xmx512m
    resources:
      requests:
        memory: 1024Mi
        cpu: 100m
      limits:
        memory: 1024Mi
        cpu: 1
    affinity:
      podAntiAffinity:
        preferredDuringSchedulingIgnoredDuringExecution:
          - weight: 1
            podAffinityTerm:
              topologyKey: kubernetes.io/hostname
              labelSelector:
                matchLabels:
                  role: master
    tolerations: []
    nodeSelector: {}
  dataNode:
    count: 2
    storageSize: 18Gi
    storageClass: vsphere-csi
    javaOpts: -Xms512m -Xmx512m
    resources:
      requests:
        memory: 1024Mi
        cpu: 200m
      limits:
        memory: 1024Mi
        cpu: 1
    affinity:
      podAntiAffinity:
        preferredDuringSchedulingIgnoredDuringExecution:
          - weight: 1
            podAffinityTerm:
              topologyKey: kubernetes.io/hostname
              labelSelector:
                matchLabels:
                  role: data
    tolerations: []
    nodeSelector: {}
  clientNode:
    count: 1
    javaOpts: -Xms512m -Xmx512m
    resources:
      requests:
        memory: 1024Mi
        cpu: 200m
      limits:
        memory: 1024Mi
        cpu: 1
    affinity:
      podAntiAffinity:
        preferredDuringSchedulingIgnoredDuringExecution:
          - weight: 1
            podAffinityTerm:
              topologyKey: kubernetes.io/hostname
              labelSelector:
                matchLabels:
                  role: client
    tolerations: []
    nodeSelector: {}
  # Config for https://www.elastic.co/guide/en/elasticsearch/client/curator/5.8/about.html
  curator:
    enabled: true
    resources:
      limits:
        cpu: 100m
        memory: 128Mi
      requests:
        cpu: 10m
        memory: 32Mi
    affinity: {}
    nodeSelector: {}
    tolerations: []
    retention:
      kubeAuditSizeGB: 4
      kubeAuditAgeDays: 3
      kubernetesSizeGB: 10
      kubernetesAgeDays: 3
      otherSizeGB: 1
      otherAgeDays: 7
      # (Optional) retention for indices matched by 'postgresql-*'
      # postgresql: false
      # postgresqlSizeGB: 30
      # postgresqlAgeDays: 30
  # Index state management
  ism:
    # Overwrite ism policies
    overwritePolicies: true
    rolloverSizeGB: 1
    rolloverAgeDays: 1
    # Create default policies - kubernetes, kubeaudit, and other
    defaultPolicies: true
    additionalPolicies: {}
  # Snapshot and snapshot lifecycle configuration
  snapshot:
    enabled: true
    min: 7
    max: 14
    ageSeconds: 864000
    retentionSchedule: 0 1 * * * # 1am
    backupSchedule: 0 */12 * * * # run twice/day
  extraRoles: []
  # - role_name: log_reader
  #   definition:
  #     index_permissions:
  #     - index_patterns:
  #       - "kubernetes-*"
  #       allowed_actions:
  #       - "read"
  extraRoleMappings: []
  # - mapping_name: readall_and_monitor
  #   definition:
  #    users:
  #      - "Developer Name"
  overwriteTemplates: true
  # Create default index templates - kubernetes, kubeaudit, and other
  defaultTemplates: true
  additionalTemplates: {}
  exporter:
    resources: {}
    #   requests:
    #     cpu: 100m
    #     memory: 128Mi
    #   limits:
    #     cpu: 100m
    #     memory: 128Mi
    tolerations: []
fluentd:
  # Enable log collection in the service cluster
  # and store in object storage via fluentd aggregator.
  enabled: true
  resources:
    limits:
      cpu: 500m
      memory: 200Mi
    requests:
      cpu: 100m
      memory: 200Mi
  tolerations: []
  affinity: {}
  nodeSelector: {}
  useRegionEndpoint: false
  aggregator:
    resources:
      limits:
        cpu: 500m
        memory: 1000Mi
      requests:
        cpu: 300m
        memory: 300Mi
    tolerations: []
    affinity: {}
    nodeSelector: {}
# Log retention for service cluster logs stored in object storage.
logRetention:
  days: 7
influxDB:
  users:
    admin: admin
    wcWriter: wcWriter
    scWriter: scWriter
  createdb: true
  resources:
    requests:
      memory: 4Gi
      cpu: 0.5
    limits:
      memory: 8Gi
      cpu: 2
  persistence:
    size: 10Gi
  tolerations: []
  affinity: {}
  nodeSelector: {}
  # Configuration for size based retention
  retention:
    # Enable size based retention job
    enabled: true
    sizeWC: 4500000
    sizeSC: 4500000
    resources:
      requests:
        cpu: 50m
        memory: 100Mi
      limits:
        cpu: 250m
        memory: 500Mi
    # The duration of the retention policy for each database
    durationWC: 2d
    durationSC: 3d
  backup:
    enabled: true
    schedule: 0 0 * * *
    startingDeadlineSeconds: 200
    resources:
      requests:
        cpu: 50m
        memory: 100Mi
      limits:
        cpu: 250m
        memory: 300Mi
  backupRetention:
    enabled: true
    daysToRetain: 7
    schedule: 0 0 * * *
    startingDeadlineSeconds: 200
    resources:
      requests:
        cpu: 50m
        memory: 100Mi
      limits:
        cpu: 250m
        memory: 300Mi
alerts:
  alertTo: "null"
  opsGenieHeartbeat:
    enabled: false
    url: https://api.eu.opsgenie.com/v2/heartbeats
    name: set-me
  slack:
    channel: set-me
  opsGenie:
    apiUrl: https://api.eu.opsgenie.com
ck8sdash:
  enabled: true
  tolerations: []
  affinity: {}
  nodeSelector: {}
  nginx:
    resources:
      requests:
        memory: 64Mi
        cpu: 50m
      limits:
        memory: 128Mi
        cpu: 100m
  server:
    resources:
      requests:
        memory: 64Mi
        cpu: 50m
      limits:
        memory: 128Mi
        cpu: 100m
externalTrafficPolicy:
  local: false
  whitelistRange:
    global: 0.0.0.0/0
    ck8sdash: false
    dex: false
    kibana: false
    elasticsearch: false
    harbor: false
    userGrafana: false
    opsGrafana: false
    prometheusWc: false
nfsProvisioner:
  resources:
    limits:
      cpu: 100m
      memory: 128Mi
    requests:
      cpu: 100m
      memory: 128Mi
  tolerations: []
  affinity: {}
  nodeSelector: {}
ingressNginx:
  controller:
    # Chart deploys correctly but does not work with resourceRequests
    resources: {}
    # limits:
    #   cpu: 100m
    #   memory: 64Mi
    # requests:
    #   cpu: 100m
    #   memory: 64Mi
    tolerations:
      - key: nodeType
        operator: Exists
        effect: NoSchedule
    affinity: {}
    nodeSelector: {}
    config:
      useProxyProtocol: false
    useHostPort: true
    service:
      enabled: false
      type: set-me
      annotations: set-me
    # Will add custom configuration options to Nginx https://kubernetes.github.io/ingress-nginx/user-guide/nginx-configuration/configmap/
    additionalConfig: {}
  defaultBackend:
    # Chart deploys correctly but does not work with resourceRequests
    resources: {}
    # limits:
    #   cpu: 100m
    #   memory: 64Mi
    # requests:
    #   cpu: 100m
    #   memory: 64Mi
    tolerations:
      - key: nodeType
        operator: Equal
        value: elastisys
        effect: NoSchedule
    affinity: {}
    nodeSelector: {}
velero:
  enabled: true
  tolerations: []
  nodeSelector: {}
  resources:
    limits:
      cpu: 200m
      memory: 200Mi
    requests:
      cpu: 100m
      memory: 100Mi
  restic:
    tolerations: []
    resources:
      limits:
        cpu: 200m
        memory: 200Mi
      requests:
        cpu: 100m
        memory: 100Mi
restore:
  cluster: false
  velero: false
  veleroBackupName: latest
issuers:
  letsencrypt:
    enabled: true
    prod:
      email: jakub@elastisys.com
    staging:
      email: jakub@elastisys.com
  extraIssuers: []
certmanager:
  resources: {}
  nodeSelector: {}
  tolerations: {}
  affinity: {}
  webhook:
    resources: {}
    nodeSelector: {}
    tolerations: {}
    affinity: {}
  cainjector:
    resources: {}
    nodeSelector: {}
    tolerations: {}
    affinity: {}
